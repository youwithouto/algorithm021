# 学习笔记

## Trie

- 数据结构
  - 多杈树
- 核心思想
  - 最大限度地减少无谓字符串的比较
  - 查询效率比哈希表高
- 基本性质
  - 节点本身不存完整单词
  - 从根节点到某一一节点，路径上经过的字符连接起来，为该节点对应的字符串
  - 每个节点的所有子节点路径代表的字符都不相同

## Disjoint Set

- 使用场景
  - 组团、配对
    - 两个个体是否属于同一群组
    - 两个群组是否是同一群组
    - 合并群组

- 基本操作
  - `makeSet(s)`
    - 建立一个新的并查集，其中包含 s 个单元素集合
  - `unionSet(x, y)`
    - 把元素 x 和元素 y 所在的集合合并，要求 x 和 y 所在的集合不相交，如果相交则不合并
  - `find(x)`
    - 找到元素 x 所在的集合的代表
    - 也可以判断两个元素是否属于同一集合
      - 只需找到并比较他们的集合的代表

- 性质
  - 集合的领头元素有 `parent[i] = i`
    - 自己就是自己的父元素，自己值根元素


```python
class UnionFind:
    def init(p):
        p = [i for i in range(0)]
    
    def union(self, p, i, j):
        p1 = self.parent(p, i)
        p2 = self.parent(p, j)
        p[p1] = p2

    def parent(self, p, i):
        root = i
        while p[root] != root:
            root = p[root]
        while p[i] != i:    # 路径压缩，统一同一集合中所有蒜素的父元素
            x, i, p[x] = i, p[i], root
        return root

```


## 高级搜索（之前初级搜索内容的进阶 ）

- 初级搜索（暴力搜索）
  1. 朴素搜索
  2. 优化方式
      - 不重复（fibonacci）
      - 剪枝（生成括号问题）
  3. 搜索方向（栈和队列）
      - DFS
      - BFS
- 高级搜索
  - 剪枝
    - 在遍历状态树的时候，缓存重复分支或非最优分支
  - 回溯
    - 采用试错的方式，尝试分步去解决每一个问题。在解决问题的过程中，当它通过尝试发现现有的答案不能得到有效的正确的解答时，它将取消上一步（甚至几步）的计算，再通过其他可能的分步解答再次尝试寻找问题的答案
    - 通常使用最简单的递归方法实现
      - 在重复上述步骤后可能得到两种情况
        1. 找到一个可能存在的正确答案
        2. 在尝试了所有可能的分步方法后，宣告该问题没有答案
    - 在最坏的情况下，回溯法会导致一次时间复杂度为指数的计算
  - 双向 BFS
  - 启发式搜索（优先队列）
    - A*
  




## 高级树、AVL 树和红黑树

- 树
- 二叉树
    - 前序：根左右
    - 中序：左根右
    - 后序：左右根
    - 如果一棵树是二叉搜索树，那么它的中序就是有序的
- 二叉搜索树
  - 查找
  - 添加
  - 删除
- 平衡二叉树（Wiki 很多种）
  - AVL 树
    - 平衡因子
      - 左子树的高度减去右子树的高度（有时相反）
      - 取值：-1，0，1
      - 维持所有节点的平衡因子都为 -1，0，1
    - 通过旋转操作进行平衡（四种）
      - Wiki: self-balancing binary search tree
      - 左旋
      - 右旋
      - 左右旋
      - 右左旋
    - 不足
      - 节点需要存储额外信息、且调整次数频繁
        - 引入近似平衡二叉树
  - 红黑树
    - 引入近似平衡二叉树
      - 能够确保任何一个节点的左右子树的高度差小于两倍（高度大的最多是小的的高度的二倍）
        - 每个节点要么是红色，要么是黑色
        - 根节点是黑色
        - 每个叶子节点（NIL 节点，空节点）是黑色
        - 不能有相邻的两个红色节点
        - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点
  - 2-3 树
  - B 树
  - Splay tree
  - Treap
